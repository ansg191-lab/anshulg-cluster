#!/usr/bin/env bash

set -eu

USER="git"
GROUP="git"
GITDIR="/srv/git"

# renovate: datasource=github-releases depName=ansg191/github-mirror
GH_MIRROR_VERSION="0.1.4"
# renovate: datasource=github-releases depName=restic/restic
RESTIC_VERSION="0.18.0"
# renovate: datasource=github-releases depName=creativeprojects/resticprofile
RESTICPROFILE_VERSION="0.30.0"

cleanup() {
	echo "Cleaning up..."
	# Restore cron
	echo "Restarting cron..."
	systemctl start cron

	# Cleanup root
	echo "Cleaning up root..."
	rm -rf root

	echo "Done."
}

disable_cron() {
	echo "::group::Stopping cron"
	local cron_pid children

	echo "Waiting for cron jobs to finish..."
	cron_pid=$(pidof cron || true)
	if [[ -n $cron_pid ]]; then
		while true; do
			children=$(pgrep -P "$cron_pid" || true)
			if [[ -z $children ]]; then
				echo "No cron jobs are running."
				break
			else
				echo "Waiting for cron jobs to finish..."
				sleep 5
			fi
		done
	fi

	echo "Stopping cron..."
	systemctl stop cron

	echo "Cron disabled..."
	echo "::endgroup::"
}

check_gitdir() {
	# Check that /srv/git exists and is mounted
	echo "::group::Checking $GITDIR"
	if [ ! -d $GITDIR ]; then
	  echo "Directory $GITDIR does not exist. Creating it."
	  mkdir -p $GITDIR
	fi

	echo "Checking if /srv/git is mounted..."
	if ! mountpoint -q $GITDIR; then
		echo "$GITDIR is not mounted. Exiting." >&2
		exit 1
	fi
	echo "$GITDIR is mounted."

	echo "Creating $GROUP group..."
	if ! getent group $GROUP > /dev/null; then
	  echo "Group $GROUP does not exist. Creating it."
	  groupadd $GROUP
	else
	  echo "Group $GROUP already exists."
	fi

	echo "::endgroup::"
}

install_packages() {
	echo "::group::Installing packages"
	apt-get update
	xargs apt-get install -y < packages.txt
	echo "::endgroup::"
}

copy_root() {
	echo "::group::Copying root"

	echo "Setting permissions..."
	chown -R root:root root/etc
	chown -R $USER:$GROUP root/srv/git
	chown -R root:root root/usr/local/sbin

	echo "Copying files..."
	rsync -a root/ /

	echo "::endgroup::"
}

install_ca() {
	# Install CA certificates
	echo "::group::Installing CA certificates"
	wget -O /home/anshulgupta/ca.crt http://privateca-content-64cbe468-0000-233e-beaa-14223bc3fa9e.storage.googleapis.com/c745acb2f145f7f9e343/ca.crt
	chmod 644 /home/anshulgupta/ca.crt
	cp /home/anshulgupta/ca.crt /usr/local/share/ca-certificates/anshulg.crt
	update-ca-certificates
	echo "::endgroup::"
}

install_caddy() {
	# Install caddy
	echo "::group::Installing Caddy"
	systemctl enable caddy
	systemctl start caddy
	systemctl restart caddy
	echo "::endgroup::"
}

install_cgit() {
	# Install cgit
	echo "::group::Installing cgit"
	systemctl enable fcgiwrap.socket fcgiwrap.service
	systemctl start fcgiwrap.socket fcgiwrap.service

	echo "Making cgit available to caddy..."
	# Create systemd override for fcgiwrap socket to change ownership to caddy
	mkdir -p /etc/systemd/system/fcgiwrap.socket.d

	tee /etc/systemd/system/fcgiwrap.socket.d/override.conf > /dev/null <<EOF
[Socket]
SocketUser=caddy
SocketGroup=caddy
EOF
	systemctl daemon-reexec
	systemctl daemon-reload
	systemctl restart fcgiwrap.socket

	# Wait for socket to be created
	sleep 5

	echo "Checking socket ownership..."
	SOCKET_PATH="/run/fcgiwrap.socket"

	# Verify socket ownership
	OWNER=$(stat -c '%U' "$SOCKET_PATH")
	GROUP=$(stat -c '%G' "$SOCKET_PATH")

	if [[ "$OWNER" != "caddy" || "$GROUP" != "caddy" ]]; then
	  echo "Error: Socket $SOCKET_PATH is owned by $OWNER:$GROUP, expected caddy:caddy" >&2
	  exit 1
	else
	  echo "Success: Socket $SOCKET_PATH is correctly owned by caddy:caddy"
	fi

	echo "::endgroup::"
}

setup_git_user() {
	echo "::group::Setting up git user"
	# Check if the git user exists
	if id "$USER" &>/dev/null; then
	  echo "User $USER exists."
	else
	  echo "User $USER does not exist. Creating it."
	  useradd -m -d $GITDIR -g $GROUP -s /usr/bin/git-shell $USER
	fi

	# Create .ssh directory if necessary
	if [ ! -d $GITDIR/.ssh ]; then
	  echo "Creating .ssh directory for $USER."
	  mkdir -p $GITDIR/.ssh
	  chown $USER:$GROUP $GITDIR/.ssh
	  chmod 700 $GITDIR/.ssh
	fi

	# Create authorized_keys file if necessary
	if [ ! -f $GITDIR/.ssh/authorized_keys ]; then
	  echo "Creating authorized_keys file for $USER."
	  touch $GITDIR/.ssh/authorized_keys
	  chown $USER:$GROUP $GITDIR/.ssh/authorized_keys
	  chmod 600 $GITDIR/.ssh/authorized_keys
	fi

	# Ensure /srv/git is owned by the git user
	chown -R $USER:$GROUP $GITDIR
}

add_crontab_entry() {
	local cron_user="$1"
	local cron_job="$2"

	echo "Adding $cron_job to $cron_user's crontab..."
	TMP_CRON=$(mktemp)

	# shellcheck disable=SC2024
	if ! crontab -u "$cron_user" -l > "$TMP_CRON" 2>/dev/null; then
		{
			echo "# Empty crontab created"
			echo "# This file was automatically generated by setup.sh"
			echo "# Edit at your own risk"
			echo "# You can add your own cron jobs below this line"
			echo "#"
		} > "$TMP_CRON"
	fi

	# Check if job is already in crontab
    if ! grep -Fxq "$cron_job" "$TMP_CRON"; then
        echo "$cron_job" >> "$TMP_CRON"
        crontab -u "$cron_user" "$TMP_CRON"
        echo "Cron job added for user $cron_user."
    else
        echo "Cron job already exists in $cron_user's crontab."
    fi
    rm "$TMP_CRON"
}

setup_mirroring() {
	echo "::group::Setting up mirroring"
	# Download and install github_mirror
	echo "Downloading github_mirror..."
	wget -qO github_mirror.deb "https://github.com/ansg191/github-mirror/releases/download/v${GH_MIRROR_VERSION}/github_mirror-${GH_MIRROR_VERSION}-Linux-x86_64.deb"
	echo "Installing github_mirror..."
	apt-get install -y ./github_mirror.deb
	rm github_mirror.deb

	# Ensure tokens directory exists
	echo "Creating tokens directory..."
	mkdir -p $GITDIR/tokens
	chown "$USER:$GROUP" $GITDIR/tokens
	chmod 700 $GITDIR/tokens

	# Setup cronjob
	CRON_JOB="*/5 * * * * /usr/bin/github_mirror -C /etc/github_mirror.conf --quiet"
	add_crontab_entry "$USER" "$CRON_JOB"

	echo "::endgroup::"
}

setup_mta() {
	echo "::group::Setting up MTA"

	FASTMAIL_PASS=$(tr -d '\n' < fastmail_pass.txt)

	# Configure nullmailer
	echo "Configuring nullmailer remotes..."
	echo "smtp.fastmail.com smtp --port=587 --starttls --auth-login --user=ansg191@anshulg.com --pass=$FASTMAIL_PASS" > remotes
	mv remotes /etc/nullmailer/remotes
	chown mail:mail /etc/nullmailer/remotes
	chmod 600 /etc/nullmailer/remotes

	# Configure /etc/mailname
	echo "Configuring /etc/mailname..."
	echo "git.anshulg.com" | tee /etc/mailname > /dev/null
	chown root:root /etc/mailname
	chmod 644 /etc/mailname

	echo "Restarting nullmailer..."
	systemctl restart nullmailer

	echo "::endgroup::"
}

setup_notion_script() {
	echo "::group::Setting up Notion Disk Monitor script"

	# Create .env.notion file
	echo "Creating .env.notion file..."
	touch $GITDIR/.env.notion
	chown "$USER:$GROUP" $GITDIR/.env.notion
	chmod 600 $GITDIR/.env.notion

	# Create a cron job to run the script every hour
	CRON_JOB="0 * * * * /usr/bin/python3 $GITDIR/notion-df.py"
	add_crontab_entry "$USER" "$CRON_JOB"

	echo "::endgroup::"
}

setup_firewall() {
	echo "::group::Setting up firewall"
	# Enable and start nftables
	systemctl enable nftables
	systemctl start nftables

	# Manually load the rules
	nft -f /etc/nftables.conf
	echo "Firewall rules loaded."

	# Setup blocklist
	/usr/local/sbin/update-blocklists.sh

	# Add cron job to update blocklists every hour (offset to 3 minutes to avoid conflict with other jobs)
	CRON_JOB="3 * * * * /usr/bin/bash /usr/local/sbin/update-blocklists.sh"
	add_crontab_entry "root" "$CRON_JOB"

	echo "::endgroup::"
}

setup_fail2ban() {
	echo "::group::Setting up fail2ban"
	# Create a jail.d/customization.local file
	mkdir -p /etc/fail2ban/jail.d
	tee /etc/fail2ban/jail.d/customization.local > /dev/null <<EOF
[sshd]
enabled = true
bantime = 1w
findtime = 1d

[DEFAULT]
destemail = root@git.anshulg.com
mta = mail

banaction = nftables
banaction_allports = nftables[type=allports]

action = %(action_)s
EOF
	chmod 644 /etc/fail2ban/jail.d/customization.local

	# Restart fail2ban
	systemctl restart fail2ban
	echo "::endgroup::"
}

install_restic() {
	echo "::group::Installing restic and resticprofile"
	# Download and install restic
	echo "Downloading restic..."
	wget -qO restic.bz2 "https://github.com/restic/restic/releases/download/v$RESTIC_VERSION/restic_${RESTIC_VERSION}_linux_amd64.bz2"
	echo "Installing restic..."
	bzip2 -d restic.bz2
	chmod +x restic
	mv restic /usr/local/bin/

	# Download and install resticprofile
	echo "Downloading resticprofile..."
	wget -qO resticprofile.tar.gz "https://github.com/creativeprojects/resticprofile/releases/download/v$RESTICPROFILE_VERSION/resticprofile_no_self_update_${RESTICPROFILE_VERSION}_linux_amd64.tar.gz"
	echo "Installing resticprofile..."
	mkdir resticprofile
	tar -xzf resticprofile.tar.gz -C resticprofile
	rm resticprofile.tar.gz
	mv resticprofile/resticprofile /usr/local/bin/
	rm -rf resticprofile

	# Print version
	restic version
	resticprofile version

	# Install bash completion
	restic generate --bash-completion /etc/bash_completion.d/restic
	chmod +x /etc/bash_completion.d/restic
	resticprofile generate --bash-completion > /etc/bash_completion.d/resticprofile
    chmod +x /etc/bash_completion.d/resticprofile

	echo "::endgroup::"
}

setup_backup() {
	echo "::group::Setting up backups"

	# Check files
	if [ ! -f /etc/resticprofile/password.txt ]; then
		echo "Error: /etc/resticprofile/password.txt does not exist. Exiting." >&2
		exit 1
	fi
	chmod 400 /etc/resticprofile/password.txt

	if [ ! -f /etc/resticprofile/auth.txt ]; then
		echo "Error: /etc/resticprofile/auth.txt does not exist. Exiting." >&2
		exit 1
	fi
	chmod 400 /etc/resticprofile/auth.txt

	CRON_JOB="21 11 * * * . /etc/resticprofile/env.sh ; /usr/local/bin/resticprofile backup --quiet"
	add_crontab_entry "root" "$CRON_JOB"

	echo "::endgroup::"
}

# Check if the script is run as root
if [ "$(id -u)" -ne 0 ]; then
	echo "This script must be run as root. Please use sudo."
	exit 1
fi

# Main script execution
trap cleanup EXIT
disable_cron
install_packages
check_gitdir
copy_root
install_ca
setup_firewall
setup_fail2ban
setup_mta
setup_git_user
install_caddy
install_cgit
setup_mirroring
setup_notion_script
install_restic
setup_backup
